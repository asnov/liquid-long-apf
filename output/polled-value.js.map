{"version":3,"file":"polled-value.js","sourceRoot":"","sources":["../source/polled-value.ts"],"names":[],"mappings":";;AAEA,MAAa,WAAW;IAUvB,YAAmB,SAAoB,EAAE,OAA8B,EAAE,uBAA+B,EAAE,YAAoB;QAH7G,cAAS,GAAwD,EAAE,CAAA;QAC5E,oBAAe,GAAe,IAAI,CAAA;QAanC,qBAAgB,GAAG,CAAC,QAAsD,EAAQ,EAAE;YAC1F,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;QAC9B,CAAC,CAAA;QAEM,aAAQ,GAAG,KAAK,IAAmB,EAAE;YAC3C,MAAM,IAAI,CAAC,gBAAgB,CAAA;YAC3B,6JAA6J;YAC7J,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE,CAAA;QAC3B,CAAC,CAAA;QAEO,UAAK,GAAG,KAAK,IAAqB,EAAE;YAC3C,IAAI;gBACH,IAAI,IAAI,CAAC,eAAe,KAAK,IAAI;oBAAE,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,CAAA;gBAC9E,MAAM,aAAa,GAAG,IAAI,CAAC,aAAa,CAAA;gBACxC,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,OAAO,EAAE,CAAA;gBACtC,IAAI,CAAC,aAAa,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAA;gBAChD,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAA;gBAC5B,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,aAAa,EAAE,aAAa,CAAC,CAAC,CAAA;gBAC/E,OAAO,IAAI,CAAC,aAAa,CAAA;aACzB;oBAAS;gBACT,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,uBAAuB,EAAE,IAAI,CAAC,KAAK,CAAC,CAAA;aACxF;QACF,CAAC,CAAA;QAhCA,IAAI,CAAC,SAAS,GAAG,SAAS,CAAA;QAC1B,IAAI,CAAC,OAAO,GAAG,OAAO,CAAA;QACtB,IAAI,CAAC,uBAAuB,GAAG,uBAAuB,CAAA;QACtD,IAAI,CAAC,aAAa,GAAG,YAAY,CAAA;QACjC,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,KAAK,EAAE,CAAA;IACrC,CAAC;IAED,IAAW,MAAM,KAAa,OAAO,IAAI,CAAC,aAAa,CAAA,CAAC,CAAC;IACzD,IAAW,MAAM,KAAsB,OAAO,IAAI,CAAC,gBAAgB,IAAI,IAAI,CAAC,KAAK,EAAE,CAAA,CAAC,CAAC;CAyBrF;AA5CD,kCA4CC","sourcesContent":["import { Scheduler } from './scheduler'\n\nexport class PolledValue<TValue> {\n\tprivate readonly scheduler: Scheduler\n\tprivate readonly fetcher: () => Promise<TValue>\n\tprivate readonly frequencyInMilliseconds: number\n\n\tprivate lastKnownGood: TValue\n\tprivate outstandingFetch: Promise<TValue> | null\n\tprivate readonly listeners: Array<(newValue: TValue, oldValue: TValue) => void> = []\n\tprivate scheduledTaskId: any | null = null\n\n\tpublic constructor(scheduler: Scheduler, fetcher: () => Promise<TValue>, frequencyInMilliseconds: number, defaultValue: TValue) {\n\t\tthis.scheduler = scheduler\n\t\tthis.fetcher = fetcher\n\t\tthis.frequencyInMilliseconds = frequencyInMilliseconds\n\t\tthis.lastKnownGood = defaultValue\n\t\tthis.outstandingFetch = this.fetch()\n\t}\n\n\tpublic get cached(): TValue { return this.lastKnownGood }\n\tpublic get latest(): Promise<TValue> { return this.outstandingFetch || this.fetch() }\n\n\tpublic registerListener = (listener: (newValue: TValue, oldValue: TValue) => void): void => {\n\t\tthis.listeners.push(listener)\n\t}\n\n\tpublic shutdown = async (): Promise<void> => {\n\t\tawait this.outstandingFetch\n\t\t// this is sketchy, it depends on this continuation getting executed after the `fetch` continuation. need to verify if that is standardized or not just lucky\n\t\tthis.scheduler.cancelAll()\n\t}\n\n\tprivate fetch = async (): Promise<TValue> => {\n\t\ttry {\n\t\t\tif (this.scheduledTaskId !== null) this.scheduler.cancel(this.scheduledTaskId)\n\t\t\tconst previousValue = this.lastKnownGood\n\t\t\tthis.outstandingFetch = this.fetcher()\n\t\t\tthis.lastKnownGood = await this.outstandingFetch\n\t\t\tthis.outstandingFetch = null\n\t\t\tthis.listeners.forEach(listener => listener(this.lastKnownGood, previousValue))\n\t\t\treturn this.lastKnownGood\n\t\t} finally {\n\t\t\tthis.scheduledTaskId = this.scheduler.schedule(this.frequencyInMilliseconds, this.fetch)\n\t\t}\n\t}\n}\n"]}